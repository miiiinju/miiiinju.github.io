---
title:  "[BFS] 백준 13460 구슬 탈출 2"
excerpt: "백준 13460 구슬 탈출 2 - BFS "

categories:
  - BFS, 구현
tags:
  - [BOJ, BFS,구현, JAVA]
---
# [[BFS] 백준 13460 구슬 탈출 2 - JAVA](https://www.acmicpc.net/problem/13460)

BFS, 구현이 복잡함 

## 처음 구상한 방법  

![image](https://user-images.githubusercontent.com/111269144/227127384-bbb26ec3-0099-42cd-9b6b-2b8bed7fea5d.png)
  
빨간색 공과 파란색 공은 한 번에 움직이는데, 파란색 공이 구멍에 빠지지 않고 빨간색 공만 구멍에 빠져야 한다.  
  
공이 움직이는 메커니즘을 함수로 구현해두고, 이동에 대한 부분은 BFS로 탐색하면 해결됨  

  
   **BFS로 접근**  
   
빨간색 공과, 파란색 공의 위치를 저장하고 있는 Point 클래스를 구현해 주었다.  

~~~java
static class Point {
		int red_Y, red_X;

		int blue_Y, blue_X;

		int count;

		boolean success = false;

		public Point(int rY, int rX, int bY, int bX, int count) {
			this.red_Y = rY;
			this.red_X = rX;
			this.blue_Y = bY;
			this.blue_X = bX;
			this.count = count;
		}
		
		public Point(Point o, int count)
		{
			this.red_Y = o.red_Y;
			this.red_X = o.red_X;
			this.blue_Y = o.blue_Y;
			this.blue_X = o.blue_X;
			this.count =count;
		}

		@Override
		public int hashCode() {
			return Objects.hash(blue_X, blue_Y, red_X, red_Y);
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null) {
				return false;
			}
			if (getClass() != obj.getClass()) {
				return false;
			}
			Point other = (Point) obj;
			return blue_X == other.blue_X && blue_Y == other.blue_Y && red_X == other.red_X && red_Y == other.red_Y;
		}

	}

~~~
  
Point 인스턴스를 HashSet에 넣어 contains를 호출하는 방식으로 방문 처리를 해 주었는데  
  
문제의 조건이 ** 보드의 세로, 가로 크기를 의미하는 두 정수 N, M (3 ≤ N, M ≤ 10) ** 이라  
  
단순히 4차원 boolean 배열을 선언하여 방문처리를 해줘도 되었을 것 같다.  10^4 = 1000*4byte  

#### 구슬 이동 구현  
  
**구현**  
  
가장 먼저, 구슬이 이동할 수 없는 벽을 나타내주기 위해  
  
~~~java  
static boolean[][] map = null;
///
main function()
map = new boolean[N][M];// 벽 = false, 갈 수 있으면 true
~~~  
  
위처럼 boolean 2차원 배열을 만들어주고, 벽은 false, 이동할 수 있는 길이면 true 값을 넣어주었다.  
  
**구슬 이동**
'빨간 구슬과 파란 구슬의 크기는 한 칸을 모두 차지한다.'라는 조건이 있기에, 두 구슬이 한 칸에 있는 경우는 없다.  
  
따라서, 빨간 구슬과 파란 구슬이 다음과 같이 같은 줄에 있고  
  
\######  
#. . . RB#  
######  
  
게임 판을 왼쪽으로 기울인다고 하면  
  
\######  
#RB. . . #  
######  
위와 같은 상황이 된다.  
  
파란 공이 구멍에 빠지는 경우  
- 빨간 공이 빠지는 경우
- 빨간 공이 빠지지 않는 경우  
  
두 가지 모두 실패하는 경우이기 때문에 항상 파란색 공을 먼저 움직여주는 방법으로 구현하였다.  
  
하지만, 파란 공을 먼저 움직이는 경우에  
  
\######  
#RB. . . #  
######  
  
위와 같은 경우에서 왼쪽으로 기울일 경우 **빨간색 공이 자리를 차지하고 있다는 점을 고려**해야 이동 중 겹쳐지는 상황이 발생하지 않는다.  
  
따라서, 파란 공을 움직이기 전에 빨간 공이 벽과 맞닿아있어 더 이상 움직이지 않는 경우에는  
  
~~~java  
map[rX][rY] = false;
~~~  
위 방법을 이용하여 일시적으로 파란 공을 움직일 때 벽으로 간주하게끔 만들었다.  
  
  
  
이후, 파란 공과 빨간 공을 차례로 한 칸씩 벽에 닿기 전까지 이동하는 방식으로 구현하여 주었다.  
  
~~~java
if (!b && map[bY + dy[direction]][bX + dx[direction]]) {
				bY += dy[direction];
				bX += dx[direction];
				
				if(!suc&&!map[bY+dy[direction]][bX+dx[direction]])
				{
					map[bY][bX]=false;
				}
				if (bY == hole_Y && bX == hole_X)
				{
					map[bY][bX]=true;
					map[rY][rX]=true;
					return null;
				}
			} else {
				b = true;
				map[bY][bX]=false;
			}
~~~  
  
위 코드는 파란 공 부분인데, map 배열을 확인하여 벽인지 아닌지 확인하고  
  
벽이 아니라면 벽의 좌표를 


~~~java
	public static Point Move(Point now, int direction) {
		Point temp = now;
		boolean suc = false;
		boolean r = false, b = false;
		int rY=temp.red_Y, rX=temp.red_X, bY=temp.blue_Y, bX=temp.blue_X;
		while (true) {
			if(!suc&&!map[rY+dy[direction]][rX+dx[direction]])
			{
				map[rY][rX]=false;
			}
			if (!b && map[bY + dy[direction]][bX + dx[direction]]) {
				bY += dy[direction];
				bX += dx[direction];
				
				if(!suc&&!map[bY+dy[direction]][bX+dx[direction]])
				{
					map[bY][bX]=false;
				}
				if (bY == hole_Y && bX == hole_X)
				{
					map[bY][bX]=true;
					map[rY][rX]=true;
					return null;
				}
			} else {
				b = true;
				map[bY][bX]=false;
			}
			if (!r && map[rY + dy[direction]][rX + dx[direction]]) {
				rY +=dy[direction];
				rX += dx[direction];
				if (rY == hole_Y && rX == hole_X) {
					suc = true;
					//map[hole_Y][hole_X]=true;

				}
				if(!suc&&!map[rY+dy[direction]][rX+dx[direction]])
				{
					map[rY][rX]=false;
				}
				
			} else {
				r = true;
				if(!suc)
					map[rY][rX]=false;
			}
			if (r && b)
			{
				map[bY][bX]=true;
				map[rY][rX]=true;
				break;
			}
		}

		temp = new Point(rY,rX,bY,bX,temp.count);
		temp.success = suc;
		return temp;
	}
~~~


### 코드  

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Objects;
import java.util.Queue;
import java.util.StringTokenizer;

public class baekjoon13460_구슬_bfs {
	static boolean[][] map = null;
	static int[] dy = { 0, 0, 1, -1 };
	static int hole_Y, hole_X;
	static int[] dx = { 1, -1, 0, 0 };// r,l,down,up

	static class Point {
		int red_Y, red_X;

		int blue_Y, blue_X;

		int count;

		boolean success = false;

		public Point(int rY, int rX, int bY, int bX, int count) {
			this.red_Y = rY;
			this.red_X = rX;
			this.blue_Y = bY;
			this.blue_X = bX;
			this.count = count;
		}
		
		public Point(Point o, int count)
		{
			this.red_Y = o.red_Y;
			this.red_X = o.red_X;
			this.blue_Y = o.blue_Y;
			this.blue_X = o.blue_X;
			this.count =count;
		}

		@Override
		public int hashCode() {
			return Objects.hash(blue_X, blue_Y, red_X, red_Y);
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null) {
				return false;
			}
			if (getClass() != obj.getClass()) {
				return false;
			}
			Point other = (Point) obj;
			return blue_X == other.blue_X && blue_Y == other.blue_Y && red_X == other.red_X && red_Y == other.red_Y;
		}

	}

	public static Point Move(Point now, int direction) {
		Point temp = now;
		boolean suc = false;
		boolean r = false, b = false;
		int rY=temp.red_Y, rX=temp.red_X, bY=temp.blue_Y, bX=temp.blue_X;
		while (true) {
			if(!suc&&!map[rY+dy[direction]][rX+dx[direction]])
			{
				map[rY][rX]=false;
			}
			if (!b && map[bY + dy[direction]][bX + dx[direction]]) {
				bY += dy[direction];
				bX += dx[direction];
				
				if(!suc&&!map[bY+dy[direction]][bX+dx[direction]])
				{
					map[bY][bX]=false;
				}
				if (bY == hole_Y && bX == hole_X)
				{
					map[bY][bX]=true;
					map[rY][rX]=true;
					return null;
				}
			} else {
				b = true;
				map[bY][bX]=false;
			}
			if (!r && map[rY + dy[direction]][rX + dx[direction]]) {
				rY +=dy[direction];
				rX += dx[direction];
				if (rY == hole_Y && rX == hole_X) {
					suc = true;
					//map[hole_Y][hole_X]=true;

				}
				if(!suc&&!map[rY+dy[direction]][rX+dx[direction]])
				{
					map[rY][rX]=false;
				}
				
			} else {
				r = true;
				if(!suc)
					map[rY][rX]=false;
			}
			if (r && b)
			{
				map[bY][bX]=true;
				map[rY][rX]=true;
				break;
			}
		}

		temp = new Point(rY,rX,bY,bX,temp.count);
		temp.success = suc;
		return temp;
	}
//R와 B가 겹치는 경우만 해결하면 끝인데, 
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());

		int N = Integer.parseInt(st.nextToken());
		int M = Integer.parseInt(st.nextToken());

		map = new boolean[N][M];// 벽 = false, 갈 수 있으면 true
		int rY = -1, rX = -1, bY = -1, bX = -1;
		for (int i = 0; i < N; i++) {
			Arrays.fill(map[i], true);
			//st = new StringTokenizer(br.readLine(), "");
			String[] ary = br.readLine().split("");
			for (int j = 0; j < M; j++) {
				String temp = ary[j];
				if (temp.equals("#")) {
					map[i][j] = false;
				} else if (temp.equals("R")) {
					rY = i;
					rX = j;
				} else if (temp.equals("B")) {
					bY = i;
					bX = j;
				} else if (temp.equals("O")) {
					hole_Y = i;
					hole_X = j;
				} else
					map[i][j] = true;
			}
		}

		////////////////////////////////////////////////////
		Queue<Point> queue = new LinkedList<Point>();
		HashSet<Point> visited = new HashSet<Point>();
		visited.add(new Point(rY,rX,bY,bX,0));
		queue.add(new Point(rY, rX, bY, bX, 0));
		
		while (!queue.isEmpty()) {
			Point now = queue.poll();
			for (int i = 0; i < 4; i++) {
				Point temp = Move(now, i);
				if (temp  != null) {
					if(temp.count>=10)
					{
						System.out.println(-1);
						return ;
					}
					if (temp.success) {
							System.out.println(temp.count + 1);
							return;
						}
					if (!visited.contains(temp)) {
						

						temp.count++;
						queue.add(temp);
						visited.add(temp);
					}
				}
			}

		}
		System.out.println(-1);

	}

}

~~~  

## 생각  

- 각 상태의 배열을 사용하지 않는 방법으로도 작성할 수 있을 것 같음  
  
- hashCode와 equals를 사용하지 않는 방법의 visited 구현하기  

- 1 2 3 맨 윗줄이면 1x1 + 2x2 + 3x3 + ... + 8x8로 정답 상태를 표현하면 유일한 상태를 int 배열로도 나타낼 수 있는 visited가 존재하지 않을까?  
  
- 아무튼 어떤 기준으로 탐색할 지만 결정하면 정말 간단한 문제
  
