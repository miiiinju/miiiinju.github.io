---
title:  "[이분탐색] 프로그래머스 입국심사"
excerpt: "프로그래머스 입국심사 스티커 - 이분탐색 "

categories:
  - 이분탐색
tags:
  - [프로그래머스, 이분탐색, JAVA]
---
# [[이분탐색] 프로그래머스 입국심사 - JAVA](https://school.programmers.co.kr/learn/courses/30/lessons/43238)
  
![image](https://user-images.githubusercontent.com/111269144/222358328-a3d14421-7549-46ed-91d1-e030840beb0f.png)  
    
사실 프로그래머스 고득점 kit에 이분탐색 문제로 분류되어 있긴 하지만  
  
이분 탐색은 최적화 과정에서 필요한 사소한 부분이고  
  
문제를 푸는 데 필요한 핵심적인 시각은  
  
  **특정 시간 내에 몇 명의 입국 심사를 처리할 수 있는 지를 어떻게 효율적으로 계산하는지**  
  
라고 생각한다.  
  
## 처음 구상한 방법  
  
현재 시간을 기준으로  
  
남은 시간 + 소요시간 기준으로 정렬해서 우선순위 큐로 뽑으면 그리디하게 가능하지 않을까  
  
하지만 매번 우선 순위 큐의 값들을 바꿀 수 없고, list에서 정렬하는 건 시간복잡도가 너무 커질 것 같아서 포기 (n범위 10억)  
  
## 문제 풀이  
  
특정 시간 안에 몇 명의 입국심사 요청을 처리할 수 있는 지의 결정 문제와  
  
특정 시간의 최솟값을 구하는 최적화 문제로 나누어 풀었다.  
  
### 결정 문제  
  
시간의 흐름으로 접근하는 것이 아니라  
  
주어진 시간에서 심사원들을 전부 굴렸을 때 몇 명의 심사를 진행할 수 있는 지를 구하는 방법으로 접근  
  
  #### 의심했던 반례  
    
  n이 9이고, 심사원 [1,10]이 있는 경우 '시간 9'에 완료할 수 있음  
  하지만 시간 9로 몇 명의 심사를 진행할 수 있는 지를 구하면 9,  
  시간 10으로 구하면 11 -> 따라서 위와 같은 의심되는 경우도 문제 없음을 확인함  
    
~~~java
public static long check(long time){
        long count = 0;
        for(int i= 0;i<times.length;i++)
            count += time/times[i];
         
        //1 10이 있을 때 n이 9이면
        //위 방법으로 하면 10이 걸림
        //1만 계속하면 9만에 끝나는데
        
       //System.out.println("time : "+time+" : "+count);
        return count;    
    }
~~~
